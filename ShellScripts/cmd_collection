scp -P36000 dts_packages.zip root@10.249.0.1:/data/

unzip -d /temp test.zip

yum search xorg-x11-apps
yum install -y xorg-x11-apps.x86_64
yum whatprovides "*xhost"
yum install -y  xorg-x11-server-utils-7.7-20.el7.x86_64
yum -y install xorg-x11-xauth

systemctl  restart  sshd.service  # 重启ssh

# 用户组与用户的概念：
groupadd -g 1001 oinstall  # 创建一个用户组，并指定组id为1001
groupadd -g 1200 dba
useradd -u 1101 -g oinstall -G dba -d /home/oracle oracle  # -g: 指定用户登陆组的GID或组名；
#  -G: 指定用户除登陆组之外所属的一个或多个附加组 -d:为主目录指定一个名字，如果不想用登录名作为主目录名的话
#  -u: 为用户指定唯一的UID
chown oracle:oinstall /oracle/app/ogg/db19.3/ogg191_ma  # oracle.oinstall也是可以的，前面是用户，后面是用户组
chown oracle:oinstall /oracle/app/ogg/db19.3/ogg191_sm
chown oracle:oinstall /oracle/app/ogg/db19.3/ogg191_deploy

dd if=/dev/zero of=/home/swapfile bs=1M count=512  # 使用dd命令在/home下创建一个名为swapfile的文件，大小为512MB
mkswap /home/swapfile  # 使用 mkswap 命令将此文件作为交换文件
swapon /home/swapfile  # 启用新创建的交换文件

echo "This is a test" | sed 's/test/big test/'
sed 's/dog/cat/' demo.txt
sed -e 's/blue/red/; s/dog/cat/' demo.txt  # 要执行多个命令，使用-e选项
sed -f blue.sed demo.txt  # -f 指定文件
sed -n 's/blue/123/p' demo.txt  # -n会禁止sed编辑器的输出
sed -n '/3/p' demo.txt  # 打印包含匹配文本的行
sed -n '2,3p' demo.txt  # 打印第2,3行的数据
sed 's/blue/red/w new2.txt' demo.txt
sed '1,2w 2line.txt' demo.txt  # 特定行写入新文件
sed 's!/bin/bash!/bin/csh!' /etc/passwd  # 分隔符不一定非得是/
sed  '5,$s/blue/red/' demo.txt  # 指定范围，每一行都会输出出来，要么是原来的，要么是替换后的
sed '/qiqi/s/bash/csh/' /etc/passwd  # 只匹配存在qiqi关键字的文本
sed '2,$d' demo.txtsed '2,$d' demo.txt
sed '/number 1/d' demo.txt  # 删除含number 1的行
sed '/2/,/3/d' demo.txtsed '/2/,/3/d' demo.txt  # 搜到有2的行开始删除，搜到有3的行结束删除,后续再遇到2的时候继续开始删除
echo "Test line 2" | sed 'i\Test line 1'  # 插入到前面
echo "Test line 2" | sed 'a\Test line 1'  # 插入到后面
sed '3i\new line' demo.txt   # 插入到文件的第3行前
sed '$a\end line' demo.txt  # 插入到文件的末尾
sed '3c\changed line' demo.txt  # 修改第3行的内容
sed '2,3c\changed line' demo.txt  # 会将第2，3行的内容都替换掉
sed '/3/c\changed line' demo.txt  # 修改第3行的内容
echo 'This 1 is a test of 1 try.' | sed 'y/123/456/'  # 单个字符替换，1->4, 2->5, 3->6
sed '=' demo.txt  # 打印行号
sed -n 'l' demo.txt  # 打印数据流中的文本和不可打印的ASCII字符
sed '3r 2line.txt' demo.txt  # 于demo.txt的第3行后，插入2line.txt的内容
sed '/2a/r 2line.txt' demo.txt  # 在demo.txt中找到2a后，在这一行的后面，插入2line.txt的内容



gawk '{print $1}' demo.txt  # gawk默认的字段分隔符为任意的空白字符
gawk -F: '{print $1}' demo.txt  # 可以用-F选项指定字段分割符
echo "My name is rich" | gawk '{$4="xx"; print $0}'echo "My name is rich" | gawk '{$4="xx"; print $0}'  # 多个命令间用分号间隔
gawk -F: -f home.gawk /etc/passwdgawk -F: -f home.gawk /etc/passwd  # home.gawk 文件中的内容为：{print $1 "'s home directory is " $6}
gawk 'BEGIN {print "Hello World"}'  # BEGIN关键字后指定的脚本会在读取数据前执行

netstat -tunlp | grep 7809  #查看端口使用情况

grep -r '$#' *  # 全局搜索
